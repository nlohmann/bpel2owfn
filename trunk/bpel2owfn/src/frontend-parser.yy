%token K_ASSIGN K_CASE K_CATCH K_CATCHALL K_COMPENSATE K_COMPENSATIONHANDLER
%token K_COPY K_CORRELATION K_CORRELATIONS K_CORRELATIONSET K_CORRELATIONSETS
%token K_EMPTY K_EVENTHANDLERS K_FAULTHANDLERS K_FLOW K_FROM K_INVOKE K_LINK
%token K_LINKS K_ONALARM K_ONMESSAGE K_OTHERWISE K_PARTNER K_PARTNERLINK
%token K_PARTNERLINKS K_PARTNERS K_PICK K_PROCESS K_RECEIVE K_REPLY K_SCOPE
%token K_SEQUENCE K_SOURCE K_SWITCH K_TARGET K_TERMINATE K_THROW K_TO
%token K_VARIABLE K_VARIABLES K_WAIT K_WHILE

%token X_OPEN X_SLASH X_CLOSE X_NEXT X_EQUALS X_ELEMENTNAME
%token <yt_casestring> X_NAME
%token <yt_casestring> X_STRING

%start tProcess


%token_table


%{

#define YYDEBUG 1
#define YYERROR_VERBOSE 1  ///< for verbose error messages

// generated by kimwitu++
#include "bpel-kc-k.h"
#include "bpel-kc-yystype.h"

#include <iostream>
#include <map>

// manage attributes
std::map<int, std::map<std::string, std::string> > attributeArray;
unsigned int nodeId = 0;

kc::casestring attribute(int id, std::string name)
{
  if(attributeArray[id][name] != "")
    return kc::mkcasestring(attributeArray[id][name].c_str());
  else
    return kc::mkcasestring("\"\"");
}


using namespace kc;

// the root of the abstract syntax tree
tProcess TheProcess;

// from flex
extern int yyerror(const char *);
extern char* yytext;
extern int yylex();

%}

%type <yt_tProcess> tProcess
%type <yt_activity> activity
%type <yt_activity_list> activity_list

%type <yt_tPartnerLink_list> tPartnerLinks_opt
%type <yt_tPartnerLink_list> tPartnerLinks
%type <yt_tPartnerLink_list> tPartnerLink_list
%type <yt_tPartnerLink> tPartnerLink

%type <yt_tPartner_list> tPartners_opt
%type <yt_tPartner_list> tPartners
%type <yt_tPartner_list> tPartner_list
%type <yt_tPartner> tPartner

%type <yt_tFaultHandlers_opt> tFaultHandlers_opt
%type <yt_tFaultHandlers> tFaultHandlers
%type <yt_tCatch_list> tCatch_list
%type <yt_tCatchAll_list> tCatchAll_opt
%type <yt_tCatch> tCatch
%type <yt_tCatchAll> tCatchAll

%type <yt_tCompensationHandler_opt> tCompensationHandler_opt
%type <yt_tCompensationHandler> tCompensationHandler

%type <yt_tEventHandlers_opt> tEventHandlers_opt
%type <yt_tEventHandlers> tEventHandlers
%type <yt_tOnMessage_list> tOnMessage_list
%type <yt_tOnAlarm_list> tOnAlarm_list
%type <yt_tOnMessage> tOnMessage
%type <yt_tOnAlarm> tOnAlarm

%type <yt_tVariable_list> tVariables_opt
%type <yt_tVariable_list> tVariables
%type <yt_tVariable_list> tVariable_list
%type <yt_tVariable> tVariable

%type <yt_tCorrelationSet_list> tCorrelationSets_opt
%type <yt_tCorrelationSet_list> tCorrelationSets
%type <yt_tCorrelationSet_list> tCorrelationSet_list
%type <yt_tCorrelationSet> tCorrelationSet

%type <yt_tCorrelation_list> tCorrelations_opt
%type <yt_tCorrelation_list> tCorrelations
%type <yt_tCorrelation_list> tCorrelation_list
%type <yt_tCorrelation> tCorrelation

%type <yt_tEmpty> tEmpty
%type <yt_tInvoke> tInvoke
%type <yt_tReceive> tReceive
%type <yt_tReply> tReply
%type <yt_tAssign> tAssign

%type <yt_tCopy_list> tCopy_list
%type <yt_tCopy> tCopy
%type <yt_tFrom> tFrom
%type <yt_tTo> tTo


%type <yt_tWait> tWait
%type <yt_tThrow> tThrow
%type <yt_tTerminate> tTerminate
%type <yt_tFlow> tFlow
%type <yt_tLink_list> tLink_list
%type <yt_tLink_list> tLinks_opt
%type <yt_tLink_list> tLinks
%type <yt_tLink> tLink
%type <yt_tSwitch> tSwitch
%type <yt_tCase_list> tCase_list
%type <yt_tCase> tCase
%type <yt_tOtherwise_list> tOtherwise_opt
%type <yt_tOtherwise> tOtherwise
%type <yt_tWhile> tWhile
%type <yt_tSequence> tSequence
%type <yt_tPick> tPick
%type <yt_tScope> tScope
%type <yt_tCompensate> tCompensate
%type <yt_standardElements> standardElements
%type <yt_tTarget_list> tTarget_list
%type <yt_tTarget> tTarget
%type <yt_tSource_list> tSource_list
%type <yt_tSource> tSource

%type <yt_integer> arbitraryAttributes

%%

/*---------------------------------------------------------------------------*/

/*
  <process name="ncname" targetNamespace="uri" 
           queryLanguage="anyURI"?
           expressionLanguage="anyURI"?
           suppressJoinFailure="yes|no"?
           enableInstanceCompensation="yes|no"?
           abstractProcess="yes|no"?
           xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/">

    <partnerLinks>?
    <partners>?
    <variables>?
    <correlationSets>?
    <faultHandlers>?
    <compensationHandler>?
    <eventHandlers>?
    
    activity
  </process>

  The top-level attributes are as follows:

   * queryLanguage. This attribute specifies the XML query language used for
     selection of nodes in assignment, property definition, and other uses.
     The default for this attribute is XPath 1.0, represented by the URI of the
     XPath 1.0 specification: http://www.w3.org/TR/1999/REC-xpath-19991116.

   * expressionLanguage. This attribute specifies the expression language used
     in the process. The default for this attribute is XPath 1.0, represented
     by the URI of the XPath 1.0 specification:
     http://www.w3.org/TR/1999/REC-xpath-19991116.

  * suppressJoinFailure. This attribute determines whether the joinFailure
     fault will be suppressed for all activities in the process. The effect of
     the attribute at the process level can be overridden by an activity using
     a different value for the attribute. The default for this attribute is
     "no".

  * enableInstanceCompensation. This attribute determines whether the process
    instance as a whole can be compensated by platform-specific means. The
    default for this attribute is "no".

  * abstractProcess. This attribute specifies whether the process being defined
    is abstract (rather than executable). The default for this attribute is
    "no".
*/

tProcess:
  X_OPEN K_PROCESS arbitraryAttributes X_NEXT
  tPartnerLinks_opt
  tPartners_opt
  tVariables_opt
  tCorrelationSets_opt
  tFaultHandlers_opt
  tCompensationHandler_opt
  tEventHandlers_opt
  activity
  X_NEXT X_SLASH K_PROCESS X_CLOSE
    { TheProcess = $$ = Process($5, $6, $7, $8, $9, $10, $11, $12);
      $$->name = attribute($3->value, "name");
      $$->targetNamespace = attribute($3->value, "targetNamespace");
      $$->queryLanguage = attribute($3->value, "queryLanguage");
      $$->expressionLanguage = attribute($3->value, "expressionLanguage");
      $$->suppressJoinFailure = attribute($3->value, "suppressJoinFailure");
      $$->enableInstanceCompensation = attribute($3->value, "enableInstanceCompensation");
      $$->abstractProcess = attribute($3->value, "abstractProcess"); }
;

/*---------------------------------------------------------------------------*/

/*
  The token "activity" can be any of the following:

  Basic activities:
    * <receive>
    * <reply>
    * <invoke>
    * <assign>
    * <throw>
    * <wait>
    * <empty>
    * <terminate>

  Structured activities:
    * <sequence>
    * <switch>
    * <while>
    * <pick>
    * <flow>

  Other activities:
    * <scope>
    * <compensate>
*/

activity:
  tEmpty
    { $$ = activityEmpty($1); }
| tInvoke
    { $$ = activityInvoke($1); }
| tReceive
    { $$ = activityReceive($1); }
| tReply
    { $$ = activityReply($1); }
| tAssign
    { $$ = activityAssign($1); }
| tWait
    { $$ = activityWait($1); }
| tThrow
    { $$ = activityThrow($1); }
| tTerminate
    { $$ = activityTerminate($1); }
| tFlow
    { $$ = activityFlow($1); }
| tSwitch
    { $$ = activitySwitch($1); }
| tWhile
    { $$ = activityWhile($1); }
| tSequence
    { $$ = activitySequence($1); }
| tPick
    { $$ = activityPick($1); }
| tScope
    { $$ = activityScope($1); }
| tCompensate
    { $$ = activityCompensate($1); }
;


/******************************************************************************
  PARTNER LINKS
******************************************************************************/

/*
  The services with which a business process interacts are modeled as partner
  links in BPEL4WS. Each partner link is characterized by a partnerLinkType.
  More than one partner link can be characterized by the same partnerLinkType.
  For example, a certain procurement process might use more than one vendor
  for its transactions, but might use the same partnerLinkType for all vendors.

  <partnerLinks>
    <partnerLink name="ncname" partnerLinkType="qname" 
             myRole="ncname"? partnerRole="ncname"?>+
    </partnerLink>
  </partnerLinks>
*/

tPartnerLinks_opt:
  /* empty */
    { $$ = NiltPartnerLink_list(); }
| tPartnerLinks X_NEXT
    { $$ = $1; }
;

tPartnerLinks:
  K_PARTNERLINKS arbitraryAttributes X_NEXT
  tPartnerLink_list //1-oo
  X_SLASH K_PARTNERLINKS
    { $$ = $4; }
;

tPartnerLink_list:
  tPartnerLink X_NEXT
    { $$ = ConstPartnerLink_list($1, NiltPartnerLink_list()); }
| tPartnerLink X_NEXT tPartnerLink_list
    { $$ = ConstPartnerLink_list($1, $3); }
;

tPartnerLink:
  K_PARTNERLINK arbitraryAttributes X_NEXT X_SLASH K_PARTNERLINK
    { $$ = PartnerLink(); }
| K_PARTNERLINK arbitraryAttributes X_SLASH
    { $$ = PartnerLink(); }
;


/******************************************************************************
  PARTNERS
******************************************************************************/

/*
  While a partner link represents a conversational relationship between two
  partner processes, relationships with a business partner in general require
  more than a single conversational relationship to be established. To
  represent the capabilities required from a business partner, BPEL4WS uses the
  partner element. 

  <partners>
    <partner name="ncname">+
      <partnerLink name="ncname"/>+
    </partner>
  </partners>
*/

tPartners_opt:
  /* empty */
    { $$ = NiltPartner_list(); }
| tPartners
    { $$ = $1; }
;

tPartners:
  K_PARTNERS arbitraryAttributes X_NEXT
  tPartner_list // 1-oo
  X_SLASH K_PARTNERS
    { $$ = $4; }
;

tPartner_list:
  tPartner X_NEXT
    { $$ = ConstPartner_list($1, NiltPartner_list()); }
| tPartner X_NEXT tPartner_list
    { $$ = ConstPartner_list($1, $3); }
;

tPartner:
  K_PARTNER arbitraryAttributes X_NEXT
  tPartnerLink_list // 1-oo
  X_SLASH K_PARTNER
    { $$ = Partner($4); }
;







/******************************************************************************
  FAULT HANDLERS
******************************************************************************/

/*
  Fault handling in a business process can be thought of as a mode switch from
  the normal processing in a scope. Fault handling in BPEL4WS is always treated
  as "reverse work" in that its sole aim is to undo the partial and
  unsuccessful work of a scope in which a fault has occurred. The completion of
  the activity of a fault handler, even when it does not rethrow the fault
  handled, is never considered successful completion of the attached scope and
  compensation is never enabled for a scope that has had an associated fault
  handler invoked.

  <faultHandlers>?
    <!-- there must be at least one fault handler or default -->
    <catch faultName="qname"? faultVariable="ncname"?>*
      activity
    </catch>
    <catchAll>?
      activity
    </catchAll>
  </faultHandlers>
*/

tFaultHandlers_opt:
  /* empty */
    { $$ = NiltFaultHandlers_opt(); }
| tFaultHandlers X_NEXT
    { $$ = ConstFaultHandlers_opt($1, NiltFaultHandlers_opt()); }
;

tFaultHandlers:
  K_FAULTHANDLERS arbitraryAttributes X_NEXT
  tCatch_list // 0-oo
  tCatchAll_opt
  X_SLASH K_FAULTHANDLERS
    { $$ = FaultHandlers($4, $5); }
| K_FAULTHANDLERS arbitraryAttributes X_SLASH
    { $$ = FaultHandlers(NiltCatch_list(), NiltCatchAll_list()); }
;

tCatch_list:
  /* empty */
    { $$ = NiltCatch_list(); }
| tCatch X_NEXT tCatch_list
    { $$ = ConstCatch_list($1, NiltCatch_list()); }
;

tCatch:
  K_CATCH arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityOrCompensateContainer
  X_SLASH K_CATCH
    { $$ = Catch($4); }
;

tCatchAll_opt:
  /* empty */
    { $$ = NiltCatchAll_list(); }
| tCatchAll X_NEXT
    { $$ = ConstCatchAll_list($1, NiltCatchAll_list()); }
;

tCatchAll:
  K_CATCHALL arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityOrCompensateContainer
  X_SLASH K_CATCHALL
    { $$ = CatchAll($4); }
;






/******************************************************************************
  COMPENSATION HANDLERS
******************************************************************************/

/*
  Scopes can delineate a part of the behavior that is meant to be reversible
  in an application-defined way by a compensation handler. Scopes with
  compensation and fault handlers can be nested without constraint to arbitrary
  depth.

  <compensationHandler>?
    activity
  </compensationHandler>
*/

tCompensationHandler_opt:
  /* empty */
    { $$ = NiltCompensationHandler_opt(); }
| tCompensationHandler X_NEXT
    { $$ = ConstCompensationHandler_opt($1, NiltCompensationHandler_opt()); }
;

tCompensationHandler:
  K_COMPENSATIONHANDLER arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityOrCompensateContainer
  X_SLASH K_COMPENSATIONHANDLER
    { $$ = CompensationHandler($4); }
;






/******************************************************************************
  EVENT HANDLERS
******************************************************************************/

/*
  The whole process as well as each scope can be associated with a set of event
  handlers that are invoked concurrently if the corresponding event occurs. The
  actions taken within an event handler can be any type of activity, such as
  sequence or flow, but invocation of compensation handlers using the
  <compensate/> activity is not permitted.

  <eventHandlers>?
    <!-- Note: There must be at least one onMessage or onAlarm handler. -->
    <onMessage partnerLink="ncname" portType="qname"
               operation="ncname" variable="ncname"?>
      <correlations>?
        <correlation set="ncname" initiate="yes|no"?>+
      <correlations>
      activity
    </onMessage>
    <onAlarm for="duration-expr"? until="deadline-expr"?>*
      activity
    </onAlarm>
  </eventHandlers>
*/

tEventHandlers_opt:
  /* empty */
    { $$ = NiltEventHandlers_opt(); }
| tEventHandlers
    { $$ = ConstEventHandlers_opt($1, NiltEventHandlers_opt()); }
;

tEventHandlers:
  K_EVENTHANDLERS arbitraryAttributes X_NEXT
  tOnMessage_list // 0-oo
  tOnAlarm_list // 0-oo
  X_SLASH K_EVENTHANDLERS
    { $$ = EventHandlers($4, $5); }
| K_EVENTHANDLERS arbitraryAttributes X_SLASH
    { $$ = EventHandlers(NiltOnMessage_list(), NiltOnAlarm_list()); }
;

tOnMessage_list:
  /* empty */
    { $$ = NiltOnMessage_list(); }
| tOnMessage X_NEXT tOnMessage_list
    { $$ = ConstOnMessage_list($1, $3); }
;

tOnAlarm_list:
  /* empty */
    { $$ = NiltOnAlarm_list(); }
| tOnAlarm X_NEXT tOnAlarm_list
    { $$ = ConstOnAlarm_list($1, $3); }
;

tOnMessage:
  K_ONMESSAGE arbitraryAttributes X_NEXT
  tCorrelations_opt 
  activity X_NEXT
  X_SLASH K_ONMESSAGE
    { $$ = OnMessage($5); }
;

tOnAlarm:
  K_ONALARM arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityContainer
  X_SLASH K_ONALARM 
    { $$ = OnAlarm($4); }
;







/******************************************************************************
  VARIABLES
******************************************************************************/

/*
  Business processes specify stateful interactions involving the exchange of
  messages between partners. The state of a business process includes the
  messages that are exchanged as well as intermediate data used in business
  logic and in composing messages sent to partners.
  Variables provide the means for holding messages that constitute the state
  of a business process. The messages held are often those that have been
  received from partners or are to be sent to partners.Variables can also hold
  data that are needed for holding state related to the process and never
  exchanged with partners.

  <variables>
    <variable name="ncname" messageType="qname"?
                type="qname"? element="qname"?/>+
  </variables>
*/

tVariables_opt:
  /* empty */
    { $$ = NiltVariable_list(); }
| tVariables X_NEXT
    { $$ = $1; }
;

tVariables:
  K_VARIABLES arbitraryAttributes X_NEXT
  tVariable_list // 1-oo
  X_SLASH K_VARIABLES
    { $$ = $4; }
;

tVariable_list:
  tVariable X_NEXT
    { $$ = ConstVariable_list($1, NiltVariable_list()); }
| tVariable X_NEXT tVariable_list
    { $$ = ConstVariable_list($1, $3); }
;

tVariable:
  K_VARIABLE arbitraryAttributes X_NEXT X_SLASH K_VARIABLE
    { $$ = Variable();
      $$->name        = attribute($2->value, "name");
      $$->messageType = attribute($2->value, "messageType");
      $$->type        = attribute($2->value, "type");
      $$->element     = attribute($2->value, "element"); }
| K_VARIABLE arbitraryAttributes X_SLASH
    { $$ = Variable();
      $$->name        = attribute($2->value, "name");
      $$->messageType = attribute($2->value, "messageType");
      $$->type        = attribute($2->value, "type");
      $$->element     = attribute($2->value, "element"); }
;


/******************************************************************************
  CORRELATION SETS
******************************************************************************/

/*
  Each correlation set in BPEL4WS is a named group of properties that, taken
  together, serve to define a way of identifying an application-level
  conversation within a business protocol instance. A given message can carry
  multiple correlation sets. After a correlation set is initiated, the values
  of the properties for a correlation set must be identical for all the
  messages in all the operations that carry the correlation set and occur
  within the corresponding scope until its completion. The semantics of a
  process in which this consistency constraint is violated is undefined.
  Similarly undefined is the semantics of a process in which an activity
  with the initiate attribute set to no attempts to use a correlation set
  that has not been previously initiated.

  <correlationSets>?
    <correlationSet name="ncname" properties="qname-list"/>+
  </correlationSets>
*/

tCorrelationSets_opt:
  /* empty */
    { $$ = NiltCorrelationSet_list(); }
| tCorrelationSets X_NEXT
    { $$ = $1; }
;

tCorrelationSets:
  K_CORRELATIONSETS arbitraryAttributes X_NEXT
  tCorrelationSet_list //1-oo
  X_SLASH K_CORRELATIONSETS
    { $$ = $4; }
;

tCorrelationSet_list:
  tCorrelationSet X_NEXT
    { $$ = ConstCorrelationSet_list($1, NiltCorrelationSet_list()); }
| tCorrelationSet X_NEXT tCorrelationSet_list
    { $$ = ConstCorrelationSet_list($1, $3); }
;

tCorrelationSet:
  K_CORRELATIONSET arbitraryAttributes X_NEXT X_SLASH K_CORRELATIONSET
    { $$ = CorrelationSet(); }
| K_CORRELATIONSET arbitraryAttributes X_SLASH
    { $$ = CorrelationSet(); }
;


/******************************************************************************
  CORRELATIONS
******************************************************************************/

tCorrelations_opt:
  /* empty */
    { $$ = NiltCorrelation_list(); }
| tCorrelations X_NEXT
    { $$ = $1; }
;

tCorrelations:
  K_CORRELATIONS arbitraryAttributes X_NEXT
  tCorrelation_list //1-oo
  X_SLASH K_CORRELATIONS
    { $$ = $4; }
;

tCorrelation_list:
  tCorrelation X_NEXT
    { $$ = ConstCorrelation_list($1, NiltCorrelation_list()); }
| tCorrelation X_NEXT tCorrelation_list
    { $$ = ConstCorrelation_list($1, $3); }
;

tCorrelation:
  K_CORRELATION arbitraryAttributes X_NEXT X_SLASH K_CORRELATION
    { $$ = Correlation(); }
| K_CORRELATION arbitraryAttributes X_SLASH
    { $$ = Correlation(); }
;







/******************************************************************************
  EMPTY
******************************************************************************/

/*
  The <empty> construct allows you to insert a "no-op" instruction into a
  business process. This is useful for synchronization of concurrent
  activities, for instance.

  <empty standard-attributes>
    standard-elements
  </empty>
*/

tEmpty:
  K_EMPTY arbitraryAttributes X_NEXT
  standardElements
  X_SLASH K_EMPTY
    { $$ = Empty($4);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
| K_EMPTY arbitraryAttributes X_SLASH
    { $$ = Empty(StandardElements(NiltTarget_list(), NiltSource_list()));
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;


/******************************************************************************
  INVOKE
******************************************************************************/

/*
  The <invoke> construct allows the business process to invoke a one-way or
  request-response operation on a portType offered by a partner.

  <invoke partnerLink="ncname" portType="qname" operation="ncname"
          inputVariable="ncname"? outputVariable="ncname"?
          standard-attributes>
    standard-elements
    <correlations>?
    <catch>*
    <catchAll>?
    <compensationHandler>?
  </invoke>
*/

tInvoke:
  K_INVOKE arbitraryAttributes X_NEXT
  standardElements
  tCorrelations_opt // was: tCorrelationsWithPattern_opt
  tCatch_list //0-oo
  tCatchAll_opt
  tCompensationHandler_opt
  X_SLASH K_INVOKE
    { $$ = Invoke($4, $5, $6, $7, $8);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->inputVariable = attribute($2->value, "inputVariable");
      $$->outputVariable = attribute($2->value, "outputVariable"); }
| K_INVOKE arbitraryAttributes X_SLASH
    { $$ = Invoke(StandardElements(NiltTarget_list(), NiltSource_list()), NiltCorrelation_list(), NiltCatch_list(), NiltCatchAll_list(), NiltCompensationHandler_opt());
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->inputVariable = attribute($2->value, "inputVariable");
      $$->outputVariable = attribute($2->value, "outputVariable"); }
;


/******************************************************************************
  RECEIVE
******************************************************************************/

/*
  The <receive> construct allows the business process to do a blocking wait for
  a matching message to arrive.

  <receive partnerLink="ncname" portType="qname" operation="ncname"
           variable="ncname"? createInstance="yes|no"?
           standard-attributes>
    standard-elements
    <correlations>?
      <correlation set="ncname" initiate="yes|no"?>+
    </correlations>
  </receive>
*/

tReceive:
  K_RECEIVE arbitraryAttributes X_NEXT
  standardElements
  tCorrelations_opt
  X_SLASH K_RECEIVE
    { $$ = Receive($4, $5);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->variable = attribute($2->value, "variable");
      $$->createInstance = attribute($2->value, "createInstance"); }
| K_RECEIVE arbitraryAttributes X_SLASH
    { $$ = Receive(StandardElements(NiltTarget_list(), NiltSource_list()), NiltCorrelation_list());
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->variable = attribute($2->value, "variable");
      $$->createInstance = attribute($2->value, "createInstance"); }
;


/******************************************************************************
  REPLY
******************************************************************************/

/*
  The <reply> construct allows the business process to send a message in reply
  to a message that was received through a <receive>. The combination of a
  <receive> and a <reply> forms a request-response operation on the WSDL
  portType for the process.

  <reply partnerLink="ncname" portType="qname" operation="ncname"
         variable="ncname"? faultName="qname"?
         standard-attributes>
    standard-elements
    <correlations>?
       <correlation set="ncname" initiate="yes|no"?>+
    </correlations>
  </reply>
*/

tReply:
  K_REPLY arbitraryAttributes X_NEXT
  standardElements
  tCorrelations_opt
  X_SLASH K_REPLY
    { $$ = Reply($4, $5);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->variable = attribute($2->value, "variable");
      $$->faultName = attribute($2->value, "faultName"); }
| K_REPLY arbitraryAttributes X_SLASH
    { $$ = Reply(StandardElements(NiltTarget_list(), NiltSource_list()), NiltCorrelation_list());
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->portType = attribute($2->value, "portType");
      $$->operation = attribute($2->value, "operation");
      $$->variable = attribute($2->value, "variable");
      $$->faultName = attribute($2->value, "faultName"); }
;


/******************************************************************************
  ASSIGN
******************************************************************************/

/*
  The <assign> construct can be used to update the values of variables with new
  data. An <assign> construct can contain any number of elementary assignments.
  The syntax of the assignment activity is:

  <assign standard-attributes>
    standard-elements
    <copy>+
      from-spec
      to-spec
    </copy>
  </assign>
*/

tAssign:
  K_ASSIGN arbitraryAttributes X_NEXT
  standardElements
  tCopy_list //1-oo
  X_SLASH K_ASSIGN
    { $$ = Assign($4, $5);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;

tCopy_list:
  tCopy X_NEXT
    { $$ = ConstCopy_list($1, NiltCopy_list()); }
| tCopy X_NEXT tCopy_list
    { $$ = ConstCopy_list($1, $3); }
;

tCopy:
  K_COPY arbitraryAttributes X_NEXT
  tFrom X_NEXT
  tTo X_NEXT
  X_SLASH K_COPY
    { $$ = Copy($4, $6); }
; 

/*
  The from-spec MUST be one of the following forms except for the opaque form
  available in abstract processes:

  <from variable="ncname" part="ncname"?/>
  <from partnerLink="ncname" endpointReference="myRole|partnerRole"/>
  <from variable="ncname" property="qname"/>
  <from expression="general-expr"/>
  <from> ... literal value ... </from>
*/

tFrom:
  K_FROM arbitraryAttributes X_NEXT
  X_SLASH K_FROM
    { $$ = From();
      $$->variable = attribute($2->value, "variable");
      $$->part = attribute($2->value, "part");
      $$->query = attribute($2->value, "query");
      $$->property = attribute($2->value, "property");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->endpointReference = attribute($2->value, "endpointReference");
      $$->expression = attribute($2->value, "expression");
      $$->opaque = attribute($2->value, "opaque"); }
| K_FROM arbitraryAttributes X_SLASH
    { $$ = From();
      $$->variable = attribute($2->value, "variable");
      $$->part = attribute($2->value, "part");
      $$->query = attribute($2->value, "query");
      $$->property = attribute($2->value, "property");
      $$->partnerLink = attribute($2->value, "partnerLink");
      $$->endpointReference = attribute($2->value, "endpointReference");
      $$->expression = attribute($2->value, "expression");
      $$->opaque = attribute($2->value, "opaque"); }
;

/*
  The to-spec MUST be one of the following forms:

  <to variable="ncname" part="ncname"?/>
  <to partnerLink="ncname"/>
  <to variable="ncname" property="qname"/>  
*/

tTo:
  K_TO arbitraryAttributes X_NEXT
  X_SLASH K_TO
    { $$ = To();
      $$->expression = attribute($2->value, "expression");
      $$->opaque = attribute($2->value, "opaque");
      $$->endpointReference = attribute($2->value, "endpointReference"); }
| K_TO arbitraryAttributes X_SLASH
    { $$ = To();
      $$->expression = attribute($2->value, "expression");
      $$->opaque = attribute($2->value, "opaque");
      $$->endpointReference = attribute($2->value, "endpointReference"); }
;


/******************************************************************************
  WAIT
******************************************************************************/

/*
  The <wait> construct allows you to wait for a given time period or until a
  certain time has passed. Exactly one of the expiration criteria must be
  specified.

  <wait (for="duration-expr" | until="deadline-expr") standard-attributes>
    standard-elements
  </wait>
*/

tWait:
  K_WAIT arbitraryAttributes X_NEXT
  standardElements
  X_SLASH K_WAIT
    { $$ = Wait($4);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->For = attribute($2->value, "for"); // "for" is a keyword
      $$->until = attribute($2->value, "until"); }
| K_WAIT arbitraryAttributes X_SLASH
    { $$ = Wait(StandardElements(NiltTarget_list(), NiltSource_list()));
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->For = attribute($2->value, "for"); // "for" is a keyword
      $$->until = attribute($2->value, "until"); }
;


/******************************************************************************
  THROW
******************************************************************************/

/*
  The <throw> construct generates a fault from inside the business process.

  <throw faultName="qname" faultVariable="ncname"? standard-attributes>
    standard-elements
  </throw>
*/

tThrow:
  K_THROW arbitraryAttributes X_NEXT
  standardElements
  X_SLASH K_THROW
    { $$ = Throw($4);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->faultName = attribute($2->value, "faultName");
      $$->faultVariable = attribute($2->value, "faultVariable"); }
| K_THROW arbitraryAttributes X_SLASH
    { $$ = Throw(StandardElements(NiltTarget_list(), NiltSource_list()));
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->faultName = attribute($2->value, "faultName");
      $$->faultVariable = attribute($2->value, "faultVariable"); }
;


/******************************************************************************
  COMPENSATE
******************************************************************************/

/*
  The <compensate> construct is used to invoke compensation on an inner scope
  that has already completed normally. This construct can be invoked only from
  within a fault handler or another compensation handler.

  <compensate scope="ncname"? standard-attributes>
    standard-elements
  </compensate>
*/

tCompensate:
  K_COMPENSATE arbitraryAttributes X_NEXT
  standardElements
  X_SLASH K_COMPENSATE
    { $$ = Compensate($4);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->scope = attribute($2->value, "scope"); }
| K_COMPENSATE arbitraryAttributes X_SLASH
    { $$ = Compensate(StandardElements(NiltTarget_list(), NiltSource_list()));
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->scope = attribute($2->value, "scope"); }
;


/******************************************************************************
  TERMINATE
******************************************************************************/

/*
  The terminate activity can be used to immediately terminate the behavior of a
  business process instance within which the terminate activity is performed.
  All currently running activities MUST be terminated as soon as possible
  without any fault handling or compensation behavior.

  <terminate standard-attributes>
    standard-elements
  </terminate>
*/

tTerminate:
  K_TERMINATE arbitraryAttributes X_NEXT
  standardElements
  X_SLASH K_TERMINATE
    { $$ = Terminate($4);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
| K_TERMINATE arbitraryAttributes X_SLASH
    { $$ = Terminate(StandardElements(NiltTarget_list(), NiltSource_list()));
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;


/******************************************************************************
  FLOW
******************************************************************************/

/*
  The <flow> construct allows you to specify one or more activities to be
  performed concurrently. Links can be used within concurrent activities to
  define arbitrary control structures.

  <flow standard-attributes>
    standard-elements
    <links>?
      <link name="ncname">+
    </links>
    activity+
  </flow>
*/

tFlow:
  K_FLOW arbitraryAttributes X_NEXT
  standardElements
  tLinks_opt
  activity_list //1-oo
  X_SLASH K_FLOW
    { $$ = Flow($4, $5, $6);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;

activity_list:
  activity X_NEXT
    { $$ = Consactivity_list($1, Nilactivity_list()); }
| activity X_NEXT activity_list
    { $$ = Consactivity_list($1, $3); }
;

tLinks_opt:
  /* empty */
  { $$ = NiltLink_list(); }
| tLinks X_NEXT
  { $$ = $1; }
;

tLinks:
  K_LINKS arbitraryAttributes X_NEXT
  tLink_list // 1-oo
  X_SLASH K_LINKS
    { $$ = $4; }
;

tLink_list:
  tLink X_NEXT
    { $$ = ConstLink_list($1, NiltLink_list()); }
| tLink X_NEXT tLink_list
    { $$ = ConstLink_list($1, $3); }
;

tLink:
  K_LINK arbitraryAttributes X_NEXT X_SLASH K_LINK
    { $$ = Link();
      $$->name = attribute($2->value, "name"); }
| K_LINK arbitraryAttributes X_SLASH
    { $$ = Link();
      $$->name = attribute($2->value, "name"); }
;


/******************************************************************************
  SWITCH
******************************************************************************/

/*
  The <switch> construct allows you to select exactly one branch of activity
  from a set of choices.

  <switch standard-attributes>
    standard-elements
    <case condition="bool-expr">+
      activity
    </case>
    <otherwise>?
      activity
    </otherwise>
  </switch>
*/

tSwitch:
  K_SWITCH arbitraryAttributes X_NEXT
  standardElements
  tCase_list //1-oo
  tOtherwise_opt
  X_SLASH K_SWITCH
    { $$ = Switch($4, $5, $6);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;

tCase_list:
  tCase X_NEXT
    { $$ = ConstCase_list($1, NiltCase_list()); }
| tCase X_NEXT tCase_list
    { $$ = ConstCase_list($1, $3); }
;

tCase:
  K_CASE arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityContainer
  X_SLASH K_CASE
    { $$ = Case($4);
      $$->condition = attribute($2->value, "condition"); }
;

tOtherwise_opt:
  /* empty */
    { $$ = NiltOtherwise_list(); }
| tOtherwise X_NEXT
    { $$ = ConstOtherwise_list($1, NiltOtherwise_list()); }
;

tOtherwise:
  K_OTHERWISE arbitraryAttributes X_NEXT
  activity X_NEXT // was: tActivityContainer
  X_SLASH K_OTHERWISE
    { $$ = Otherwise($4); }
;


/******************************************************************************
  WHILE
******************************************************************************/

/*
  The <while> construct allows you to indicate that an activity is to be
  repeated until a certain success criteria has been met.

  <while condition="bool-expr" standard-attributes>
     standard-elements
     activity
  </while>
*/

tWhile:
  K_WHILE arbitraryAttributes X_NEXT
  standardElements
  activity X_NEXT
  X_SLASH K_WHILE
    { $$ = While($4, $5);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->condition = attribute($2->value, "condition"); }
;


/******************************************************************************
  SEQUENCE
******************************************************************************/

/*
  The <sequence> construct allows you to define a collection of activities to
  be performed sequentially in lexical order.

  <sequence standard-attributes>
    standard-elements
    activity+
  </sequence>
*/

tSequence:
  K_SEQUENCE arbitraryAttributes X_NEXT
  standardElements
  activity_list //1-oo
  X_SLASH K_SEQUENCE
    { $$ = Sequence($4, $5);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure"); }
;


/******************************************************************************
  PICK
******************************************************************************/

/*
  The <pick> construct allows you to block and wait for a suitable message to
  arrive or for a time-out alarm to go off. When one of these triggers occurs,
  the associated activity is performed and the pick completes.

  <pick createInstance="yes|no"? standard-attributes>
    standard-elements
    <onMessage partnerLink="ncname" portType="qname"
               operation="ncname" variable="ncname"?>+
      <correlations>?
         <correlation set="ncname" initiate="yes|no"?>+
      </correlations>
      activity
    </onMessage>
    <onAlarm (for="duration-expr" | until="deadline-expr")>*
      activity
    </onAlarm>
  </pick>

*/

tPick:
  K_PICK arbitraryAttributes X_NEXT
  standardElements
  tOnMessage X_NEXT tOnMessage_list //1-oo
  tOnAlarm_list //0-oo
  X_SLASH K_PICK
    { $$ = Pick($4, ConstOnMessage_list($5, $7), $8);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->createInstance = attribute($2->value, "createInstance"); }
;







/******************************************************************************
  SCOPE
******************************************************************************/

/*
  The <scope> construct allows you to define a nested activity with its own
  associated variables, fault handlers, and compensation handler.

  <scope variableAccessSerializable="yes|no" standard-attributes>
    standard-elements

    <variables>?
    <correlationSets>?
    <faultHandlers>?
    <compensationHandler>?
    <eventHandlers>?

    activity
  </scope>
*/

tScope:
  K_SCOPE arbitraryAttributes X_NEXT
  standardElements
  tVariables_opt
  tCorrelationSets_opt
  tFaultHandlers_opt
  tCompensationHandler_opt
  tEventHandlers_opt
  activity X_NEXT
  X_SLASH K_SCOPE
    { $$ = Scope($4, $5, $7, $8, $9, $10);
      $$->name = attribute($2->value, "name");
      $$->joinCondition = attribute($2->value, "joinCondition");
      $$->suppressJoinFailure = attribute($2->value, "suppressJoinFailure");
      $$->variableAccessSerializable = attribute($2->value, "variableAccessSerializable"); }
;







/******************************************************************************
  STANDARD ELEMENTS
******************************************************************************/

/*
  Note that the "standard-elements" referred to above are:

  <target linkName="ncname"/>*
  <source linkName="ncname" transitionCondition="bool-expr"?/>*

  where the default value of the "transitionCondition" attribute is "true()",
  the truth-value function from the default expression language XPath 1.0.
*/

standardElements:
  tTarget_list //0-oo
  tSource_list //0-oo
    { $$ = StandardElements($1, $2); }
;

tTarget_list:
  /* empty */
    { $$ = NiltTarget_list(); }
| tTarget X_NEXT tTarget_list
    { $$ = ConstTarget_list($1, $3); }
;

tTarget:
  K_TARGET arbitraryAttributes X_NEXT X_SLASH K_TARGET
    { $$ = Target(); }
| K_TARGET arbitraryAttributes X_SLASH
    { $$ = Target(); }
;

tSource_list:
  /* empty */
    { $$ = NiltSource_list(); }
| tSource X_NEXT tSource_list
    { $$ = ConstSource_list($1, $3); }
;

tSource:
  K_SOURCE arbitraryAttributes X_NEXT X_SLASH K_SOURCE
    { $$ = Source(); }
| K_SOURCE arbitraryAttributes X_SLASH
    { $$ = Source(); }
;


/*---------------------------------------------------------------------------*/

arbitraryAttributes:
  /* empty */
    { $$ = mkinteger(++nodeId); }
| X_NAME X_EQUALS X_STRING arbitraryAttributes
    { $$ = $4; attributeArray[nodeId][$1->name] = $3->name; }
;
